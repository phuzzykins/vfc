###############################################################################
####
#### X Axis
####
################################################################################

# Octopus Motor 0
[stepper_x]
step_pin: PF12
dir_pin: PF13
enable_pin: PF14

full_steps_per_rotation: 12800
microsteps: 1
rotation_distance = 40

endstop_pin: PG6
position_min: -11
position_endstop: -11
position_max: 375
homing_speed: 40
homing_retract_dist: 0

################################################################################
####
#### Y Axis
####
################################################################################

# Octopus Motor 1
[stepper_y]
step_pin: PG1
dir_pin: PG0
enable_pin: PF15

full_steps_per_rotation: 12800
microsteps: 1
rotation_distance = 40

endstop_pin: PG9
position_min: -10
position_endstop: -10
position_max: 340
homing_speed: 40
homing_retract_dist: 0

################################################################################
####
#### Z Axis
####
################################################################################

# Octopus Motor 2
[stepper_z]
step_pin: PG3
dir_pin: PF11
enable_pin: PG5

full_steps_per_rotation: 3200
microsteps: 1
gear_ratio: 2:1
rotation_distance = 5

endstop_pin: probe:z_virtual_endstop
position_min: -2 
position_max: 310
homing_speed: 10
homing_retract_dist: 5

[bltouch]
sensor_pin: PB7
control_pin: PB6
x_offset: -48.5
y_offset: 8.5
z_offset: 1.50
samples: 1
speed: 5
stow_on_each_sample: true
probe_with_touch_mode: false

################################################################################
####
#### Homing and stall detection
####
#### Whoa boy, this takes some magic to work around what Klipper thinks I
#### ought to want
####
################################################################################

####
#### We'll be declaring these pins as both endstops and DIAG pins
####
[duplicate_pin_override]
pins: PG6, PG9

####
#### We need to tell the DIAG macros when we're homing, which means
#### a homing_override section. Otherwise, the behavior here is basically
#### identical to the safe_z_home.
####
[homing_override]
set_position_z: 0
gcode:
	SET_STEPPER_ENABLE STEPPER=stepper_x ENABLE=0
	SET_STEPPER_ENABLE STEPPER=stepper_y ENABLE=0
	SET_STEPPER_ENABLE STEPPER=stepper_z ENABLE=0
	#BLTOUCH_DEBUG COMMAND=reset
	SET_STEPPER_ENABLE STEPPER=stepper_x ENABLE=1
	SET_STEPPER_ENABLE STEPPER=stepper_y ENABLE=1
	SET_STEPPER_ENABLE STEPPER=stepper_z ENABLE=1
	SET_GCODE_VARIABLE MACRO=_X_DIAG_TRIGGERED VARIABLE=homing VALUE=1
	SET_GCODE_VARIABLE MACRO=_Y_DIAG_TRIGGERED VARIABLE=homing VALUE=1
	SET_GCODE_VARIABLE MACRO=_Z_DIAG_TRIGGERED VARIABLE=homing VALUE=1
	G0 Z5 F3600
	G28 X
	G0 X10
	G28 Y
	G0 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_maximum.y/2}
	G28 Z
	UPDATE_DELAYED_GCODE ID=clear_homing_state DURATION=0.1
	 
####
#### If we clear these inline instead of in a delayed_gcode section,
#### they're already cleared by the time the DIAG_TRIGGERED macro runs
####
[delayed_gcode clear_homing_state]
gcode:
	SET_GCODE_VARIABLE MACRO=_X_DIAG_TRIGGERED VARIABLE=homing VALUE=0
	SET_GCODE_VARIABLE MACRO=_Y_DIAG_TRIGGERED VARIABLE=homing VALUE=0
	SET_GCODE_VARIABLE MACRO=_Z_DIAG_TRIGGERED VARIABLE=homing VALUE=0
	
####
#### These button defs do nothing more than call the macro, but we can't inline
#### the macro code here because we need a state variable
####
[gcode_button x_diag]
pin: PG6
press_gcode:
	_X_DIAG_TRIGGERED

[gcode_button y_diag]
pin: PG9
press_gcode:
	_Y_DIAG_TRIGGERED
	
[gcode_button z_diag]
pin: PG10
press_gcode:
	_Z_DIAG_TRIGGERED
